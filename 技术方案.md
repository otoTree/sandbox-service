这是我们最终确定的**高隔离、多租户、指纹混淆的浏览器沙箱方案**。

### 1. 核心架构 (Architecture) - 深度集成版

本项目现有的 `sandbox-service` 是一个基于 Node.js/Express 的安全执行环境，主要用于 Python 代码执行。我们将把**浏览器沙箱 (Browser Sandbox)** 作为一个新的模块集成进去，复用现有的基础设施（鉴权、配置、日志）。

*   **服务层**: 复用现有的 Express App，挂载新的路由 `/browser/*`。
*   **执行引擎**:
    *   **Python**: 继续使用 `SandboxManager` (seccomp/namespace) 进行内核级隔离。
    *   **Browser**: 使用 `Playwright` + `BrowserContext` 进行应用级隔离。
*   **网络安全**:
    *   Playwright 启动的 Context 可配置 `proxy`，指向由 `sandbox-runtime` 提供的 `HttpProxyServer`，从而复用现有的网络白名单/黑名单配置 (`sandboxConfig.network`)。
*   **指纹隔离**: 保持原方案，使用 `fingerprint-injector`。
*   **并发控制**: 在 `BrowserManager` 内部维护会话队列。

### 2. API 设计 (RESTful)

保持原设计，路径前缀与现有风格一致。

| 方法 | 路径 | 描述 | 关键参数 | 返回 |
| :--- | :--- | :--- | :--- | :--- |
| `POST` | `/browser/sessions` | 创建新会话 | `device`, `viewport` | `{ sessionId: "uuid" }` |
| `DELETE`| `/browser/sessions/:id` | 销毁会话 | - | `{ success: true }` |
| `POST` | `/browser/sessions/:id/navigate` | 页面跳转 | `url`, `waitUntil` | `{ screenshot: "...", url: "..." }` |
| `POST` | `/browser/sessions/:id/action` | 页面交互 | `action`, `selector` | `{ screenshot: "...", result: ... }` |

### 3. 安全与资源管理

*   **生命周期管理**: 设置全局最大会话数（防止内存溢出）和会话 TTL。
*   **网络沙箱集成**:
    *   在 `BrowserManager` 初始化时，利用 `sandbox-runtime` 的 `createHttpProxyServer` 启动一个本地代理。
    *   Playwright Launch 时指定 `--proxy-server` 指向该本地代理。
    *   这样浏览器的所有请求都会经过 `sandbox-runtime` 的过滤逻辑。

---

### 4. 落地实施 (Implementation)

#### 第一步：安装依赖

```bash
npm install playwright fingerprint-generator fingerprint-injector uuid
# 安装浏览器内核
npx playwright install chromium
```

#### 第二步：配置扩展 (src/config.ts)

扩展现有的配置以支持浏览器选项。

```typescript /Users/hjr/Desktop/sandbox-service/src/config.ts
// ... existing imports
import { type SandboxRuntimeConfig } from '@anthropic-ai/sandbox-runtime'

export const PORT = process.env.PORT ? Number(process.env.PORT) : 8080
export const AUTH_TOKEN = process.env.AUTH_TOKEN || 'dev'

// Browser Configuration
export const BROWSER_CONFIG = {
  maxSessions: process.env.MAX_BROWSER_SESSIONS ? Number(process.env.MAX_BROWSER_SESSIONS) : 10,
  sessionTimeout: process.env.BROWSER_SESSION_TIMEOUT ? Number(process.env.BROWSER_SESSION_TIMEOUT) : 600000, // 10 mins
  headless: process.env.BROWSER_HEADLESS !== 'false', // default true
}

// ... existing sandboxConfig
```

#### 第三步：定义数据结构与校验 (src/types.ts)

(保持原方案中的 Zod Schema 定义不变，添加到 `src/types.ts`)

#### 第四步：核心管理器 (src/services/browser-manager.ts)

集成网络代理的 Browser Manager。

```typescript /Users/hjr/Desktop/sandbox-service/src/services/browser-manager.ts
import { chromium, Browser, BrowserContext, Page } from 'playwright'
import { FingerprintGenerator } from 'fingerprint-generator'
import { FingerprintInjector } from 'fingerprint-injector'
import { v4 as uuidv4 } from 'uuid'
import { createHttpProxyServer } from '@anthropic-ai/sandbox-runtime/dist/sandbox/http-proxy.js' // 注意路径可能需要调整
import { sandboxConfig } from '../config.js'
import { BROWSER_CONFIG } from '../config.js'

interface Session {
  id: string
  context: BrowserContext
  page: Page
  lastActive: number
  queue: Promise<any>
}

export class BrowserManager {
  private static instance: BrowserManager
  private browser: Browser | null = null
  private sessions: Map<string, Session> = new Map()
  private fingerprintGenerator = new FingerprintGenerator()
  private fingerprintInjector = new FingerprintInjector()
  private proxyServer: any = null
  private proxyPort: number = 0

  private constructor() {
    setInterval(() => this.cleanupStaleSessions(), 60 * 1000)
  }

  static getInstance(): BrowserManager {
    if (!BrowserManager.instance) {
      BrowserManager.instance = new BrowserManager()
    }
    return BrowserManager.instance
  }

  private async startProxy() {
    if (this.proxyServer) return;
    
    // 利用 sandbox-runtime 的代理过滤逻辑
    // 注意：此处需要适配 sandbox-runtime 的 filter 接口
    // 这里简化处理，假设我们实现一个简单的过滤函数基于 sandboxConfig
    this.proxyServer = createHttpProxyServer({
        filter: (port, host) => {
            // TODO: 实现基于 sandboxConfig.network 的检查
            // 简单示例：
            if (sandboxConfig.network?.deniedDomains?.includes(host)) return false;
            return true;
        }
    })
    
    return new Promise<void>((resolve) => {
        this.proxyServer.listen(0, '127.0.0.1', () => {
            this.proxyPort = (this.proxyServer.address() as any).port
            console.log(`Browser Proxy started on port ${this.proxyPort}`)
            resolve()
        })
    })
  }

  private async ensureBrowser() {
    if (!this.browser) {
      await this.startProxy()
      
      console.log('Launching Browser...')
      this.browser = await chromium.launch({
        headless: BROWSER_CONFIG.headless,
        proxy: { server: `http://127.0.0.1:${this.proxyPort}` }, // 全局代理
        args: [
            '--no-sandbox', 
            '--disable-setuid-sandbox',
            '--disable-blink-features=AutomationControlled'
        ]
      })
    }
  }

  // ... createSession, execute, destroySession (与原方案类似，但在 createSession 中不再需要手动设置代理，因为全局已设置)
  // 但为了更细粒度的指纹，Context 级别也可以覆盖代理，不过全局代理通常够用。
  
  async createSession(options?: { device?: 'desktop' | 'mobile', viewport?: { width: number, height: number } }) {
    await this.ensureBrowser()
    if (this.sessions.size >= BROWSER_CONFIG.maxSessions) throw new Error('Max sessions limit reached')

    const fingerprint = this.fingerprintGenerator.getFingerprint({
        devices: options?.device === 'mobile' ? ['mobile'] : ['desktop'],
        operatingSystems: ['macos', 'windows', 'linux'],
    })

    const context = await this.browser!.newContext({
        viewport: options?.viewport || fingerprint.fingerprint.screen,
        userAgent: fingerprint.fingerprint.navigator.userAgent,
        locale: fingerprint.fingerprint.navigator.language,
        // proxy: ... // 如果需要每个会话不同代理可在此设置
    })

    await this.fingerprintInjector.attachFingerprintToPlaywright(context, fingerprint)
    const page = await context.newPage()
    const id = uuidv4()
    
    // ... session setup
    const session: Session = { id, context, page, lastActive: Date.now(), queue: Promise.resolve() }
    this.sessions.set(id, session)
    return id
  }

  // ... 其他方法保持不变
}
```

#### 第五步：路由与注册

保持原方案，注册到 `src/index.ts`。

